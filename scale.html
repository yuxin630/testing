<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        .border {
            stroke: black;
            stroke-width: 1px;
            fill: none;
        }
        .hidden {
            display: none;
        }
        #chart {
            padding-top: 10%; /* 将主图表下移，避免与顶部的按钮和控制项重叠 */
            padding-left:17%;
        }
        .x-axis-container {
            position: fixed;
            bottom: 0;
            padding-left:17%;
            width: 100%;
            background: white;
        }
        
        .top-container {
            position: fixed;
            left: 60%;  /* 将容器移到画面的中央 */
            transform: translateX(-50%);  /* 确保容器的左边界与中央对齐 */
            width: 60%;  /* 设置宽度为自适应内容 */
            display: flex;
            justify-content: center;  /* 让内部的按钮和minimap在水平上集中 */
            z-index: 1000;
            background-color: white;
            padding: 10px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .jump-buttons {
            display: flex;
            align-items: center;  /* 确保按钮在容器内垂直居中 */
            margin-right: 20px;
        }

        .jump-button {
            margin: 5px;
            padding: 5px 10px;
            cursor: pointer;
            border: 1px solid #000;
            border-radius: 5px;
            background-color: #f0f0f0;
            font-size: 12px;
            width: auto; /* 自动适应文字长度 */
            height: auto; /* 自动适应内容 */
            writing-mode: horizontal-tb; /* 保持文字水平显示 */
        }

        .control-buttons {
            display: flex;
            align-items: center;  /* 确保按钮在容器内垂直居中 */
            margin-right: 20px;
        }

        #sort-button {
            padding: 8px 20px;
            cursor: pointer;
            font-size: 12px;
            background-color: #f0f0f0;
            border: 1px solid #000;
            border-radius: 5px;
        }

        .jump-buttons, .control-buttons, .minimap-container {
            margin-left: 20px;  /* 为了不让它们紧贴在一起，增加左右间距 */
            margin-right: 20px;
        }


        .minimap-container {
            width: 200px;
            height: 100px;
            border: 1px solid #000;
            background-color: #f9f9f9;
        }
        #tooltip {
            width: auto; 
            max-width: 600px; 
            font-family: Arial, sans-serif;
            display: flex; 
            align-items: center;
        }

        #tooltip-content {
            display: flex;
            align-items: center;
        }

        #carousel {
            margin-right: 10px; 
        }

        #tooltip-title {
            font-weight: bold;
        }

        #tooltip-ratings div {
            display: flex;
            align-items: center;
            
        }

        .arrow {
            cursor: pointer;
            font-size: 24px;
            font-weight: bold;
            position: fixed;
            top: 50%;
            transform: translateY(-50%);
        }

        .arrow-left {
            left: calc(20% - 30px); /* 调整此值以将左箭头位置向右移动 */
        }

        .arrow-right {
            right: 10px; /* 让右箭头紧贴chart右侧 */
        }
    </style>
</head>
<body>
    <div class="top-container">
        <div class="jump-buttons">
            <div class="jump-button" onclick="jumpToDiningTime(60)">60 分鐘</div>
            <div class="jump-button" onclick="jumpToDiningTime(90)">90 分鐘</div>
            <div class="jump-button" onclick="jumpToDiningTime(100)">100 分鐘</div>
            <div class="jump-button" onclick="jumpToDiningTime(120)">120 分鐘</div>
            <div class="jump-button" onclick="jumpToDiningTime(150)">150 分鐘</div>
            <div class="jump-button" onclick="jumpToDiningTime('all')">所有時間</div>
        </div>
        <div class="control-buttons">
            <button id="sort-button">按評分排序</button>
        </div>
        <div class="minimap-container">
            <svg id="minimap" width="200" height="100"></svg>
        </div>
    </div>
    <div class="x-axis-container">
        <svg id="x-axis-svg" width="1200" height="50"></svg>
    </div>
    <div id="chart"></div>
    <div id="tooltip" style="display:none; position:absolute; border:1px solid #ccc; background-color:#fff; padding:10px; border-radius:8px; box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.1);">
        <div id="tooltip-content" style="display: flex; align-items: center;">
            <div id="carousel" style="position: relative; width: 150px; height: 150px; overflow: hidden; border-radius: 8px; margin-right: 10px;">
                <div id="carousel-images" style="display: flex; transition: transform 0.5s ease;">
                    <!-- 圖片動態插入 -->
                </div>
            </div>
            <div id="tooltip-details" style="flex-grow: 1;">
                <div id="tooltip-title" style="font-weight: bold;"></div>
                <div id="tooltip-rating" style="color: gold;"></div>
                <div id="tooltip-food-dishes" style="margin-top: 10px;"></div>
                <div id="tooltip-ratings" ></div>
            </div>
        </div>
    </div>
    <div class="arrow arrow-left"></div>
    <div class="arrow arrow-right"></div>    
    <script>
        let loaded = []; 
        let positions = [];
        let totalHeight =[];
        
        //用餐時間按鈕跳轉
        function jumpToDiningTime(diningTime) {
            if (!loaded.length) {
                console.error('Data is not loaded yet.');
                return;
            }
            // 處理滾動時用餐時間為空的資料
            if (diningTime === 'all') {
                
                let foundText = null;

                d3.selectAll('text').each(function() {
                    const text = d3.select(this);
                    const textContent = text.text();
                    if (textContent.includes("用餐時間:")) {
                        foundText = text.node();
                    }
                });

                if (foundText) {
                    foundText.scrollIntoView({ behavior: 'smooth', block: 'center' });
                } else {
                    console.warn(`未找到匹配的文本`);
                }
                return;
            }

            const matchingData = loaded.find(d => Number(d.r_time_low) === Number(diningTime));
            console.log('Matching data:', matchingData);
            
            if (matchingData) {
                // 使用 D3.js 選擇所有的 text 元素
                const texts = d3.selectAll('text');
                let foundText = null;

                texts.each(function() {
                    const text = d3.select(this);
                    const textContent = text.text();
                    if (textContent.includes(`用餐時間: ${diningTime}`)) {
                        foundText = text.node();
                    }
                });

                if (foundText) {
                    // 滾動到這個 text 的位置
                    foundText.scrollIntoView({ behavior: 'smooth', block: 'center' });
                } else {
                    console.warn(`未找到匹配的文本`);
                }
            } else {
                console.error(`未找到用餐時間 ${diningTime} 的數據`);
            }
        }

        

        d3.json('http://localhost/%e6%9c%9f%e6%9c%ab%e4%b8%81%e4%b8%81/foodee-main/connect_sql/index.php').then(function (data) {
            console.log('Loaded data:', data);  // 查看加载的数据
            loaded = data;

            const width = 1200;
            const height = 800;
            const margin = { top: 20, right: 50, bottom: 50, left: 40 };
            const innerRadius = 45;
            const rectWidth = 120;
            const rectHeight = 60;
            const rectSpacing = 20;
            const rowHeight = rectHeight + rectSpacing;
            const groupSpacing = 40;
            const circleRadius = 60;
            const intervalWidths = {};

            const intervals = ["區間0","區間200", "區間400", "區間600", "區間800", "區間1000"];//價錢區間
            let currentIntervals = ["區間200", "區間400", "區間600"];//預設區間
            const intervalTotals = getCurrentIntervalTotals(currentIntervals);//獲得該曲間總餐廳數(FOR WIDTH計算)
            const total = d3.sum(Object.values(intervalTotals));

            if (isNaN(total) || total === 0) {
                console.warn("Total 餐厅数为 NaN 或 0，跳过更新。");
                return;
            }

            //計算區間寬度
            currentIntervals.forEach(interval => {
                intervalWidths[interval] = (intervalTotals[interval] / total) * (width - margin.left - margin.right);
            });

            if (isNaN(total) || total === 0) {
                console.warn("Total 餐厅数为 NaN 或 0，跳过更新。");
                return;
            }
              
            currentIntervals.forEach(interval => {
                const intervalTotal = intervalTotals[interval];
                if (intervalTotal && total) {
                    intervalWidths[interval] = (intervalTotal / total) * (width - margin.left - margin.right);
                } else {
                    intervalWidths[interval] = circleRadius * 2; // 確保每個區間至少有一個圓圈的寬度
                }
            });

            const intervalPositions = {};
            let currentPosition = margin.left;
            currentIntervals.forEach(interval => {
                intervalPositions[interval] = currentPosition;
                currentPosition += intervalWidths[interval];
            });
             
            const sortedTimes = ['60', '90', '100', '120', '150', ''];
            const color = d3.scaleOrdinal(d3.schemeCategory10);

            const x = d3.scaleBand()
                .domain(intervals)
                .range([margin.left, width - margin.right])
                .padding(0.1);

            const y = d3.scaleBand()
                .domain(sortedTimes)
                .range([margin.top, height - margin.bottom])
                .padding(0.1);
            
            //將用餐時間歸類
            function categorizePrice(price) {
                if (price < 200) return "區間0";
                if (price < 400) return "區間200";
                if (price < 600) return "區間400";
                if (price < 800) return "區間600";
                if (price < 1000) return "區間800";
                return "區間1000";
            }

            document.getElementById('sort-button').addEventListener('click', function() {
                // 將資料rating重新按照高到低排

                console.log("Data sorted by rating:", data);

                // 然后更新此區間
                updateIntervals();

                console.log("Intervals updated, starting to filter and display current interval circles...");

                // 清空當前顯示
                d3.select("#chart").selectAll("*").remove();

                // 重新安排圓圈位置
                const newPositions = calculateSortedPositions(data, intervalWidths, rowHeight, rectSpacing, margin, intervalPositions);

                console.log("Sorted positions for the current interval:", newPositions);


                // 計算svg總高度
                const totalHeightValue = calculateTotalHeight(data, intervalWidths, rowHeight, groupSpacing, margin);
                if (isNaN(totalHeightValue) || totalHeightValue <= 0 || !isFinite(totalHeightValue)) {
                    console.error("Total height 计算失败，跳过绘图。");
                    return;
                }

                drawChart(intervalWidths, intervalPositions, total, totalHeightValue, newPositions);

                console.log("Chart updated successfully after sorting by rating.");
            });


            function getCurrentIntervalTotals(intervals) {
                const intervalTotals = {};
                const minWidth = circleRadius * 2; // 最小宽度为一个圆圈的直径

                intervals.forEach(interval => {
                    intervalTotals[interval] = d3.sum(data, d => categorizePrice(d.r_price_low) === interval);
                    console.log(`Interval: ${interval}, Total: ${intervalTotals[interval]}`);  // 调试信息
                });

                const total = d3.sum(Object.values(intervalTotals));
                const availableWidth = width - margin.left - margin.right;

                // 确保每个区间的宽度至少为minWidth
                intervals.forEach(interval => {
                    let calculatedWidth = (intervalTotals[interval] / total) * availableWidth;
                    intervalWidths[interval] = Math.max(minWidth, calculatedWidth);
                });

                return intervalTotals;
            }

            function updateIntervals() {

                const minIntervalWidth = 65; 
                // 清除旧的区间，确保没有重复
                currentIntervals = Array.from(new Set(currentIntervals));

                console.log("Current intervals after deduplication:", currentIntervals);

                if (!currentIntervals || currentIntervals.length === 0) {
                    console.warn("currentIntervals 为空或未定义，跳过更新。");
                    return;
                }

                // 重置 intervalWidths 对象
                Object.keys(intervalWidths).forEach(key => delete intervalWidths[key]);

                const intervalTotals = getCurrentIntervalTotals(currentIntervals);
                const total = d3.sum(Object.values(intervalTotals));

                if (isNaN(total) || total === 0) {
                    console.warn("Total 餐厅数为 NaN 或 0，跳过更新。");
                    return;
                }

                let totalUsedWidth = 0;

                // 计算每个区间的宽度
                currentIntervals.forEach(interval => {
                    intervalWidths[interval] = Math.max((intervalTotals[interval] / total) * (width - margin.left - margin.right), minIntervalWidth);
                    if (isNaN(intervalWidths[interval])) {
                        console.error(`Invalid interval width for interval: ${interval}`);
                    }
                    totalUsedWidth += intervalWidths[interval];
                });

                // 如果总使用宽度超过了画布宽度，进行缩放
                if (totalUsedWidth > (width - margin.left - margin.right)) {
                    const scaleFactor = (width - margin.left - margin.right) / totalUsedWidth;
                    currentIntervals.forEach(interval => {
                        intervalWidths[interval] *= scaleFactor;
                        if (isNaN(intervalWidths[interval])) {
                            console.error(`Invalid scaled interval width for interval: ${interval}`);
                        }
                    });
                }

                // 计算每个区间的位置
                let currentPosition = margin.left;
                currentIntervals.forEach(interval => {
                    intervalPositions[interval] = currentPosition;
                    if (isNaN(intervalPositions[interval])) {
                        console.error(`Invalid interval position for interval: ${interval}`);
                    }
                    currentPosition += intervalWidths[interval];
                });

                console.log("Interval widths after update:", intervalWidths);  // 调试信息
                console.log("Interval positions after update:", intervalPositions);  // 调试信息

                d3.select("#chart").selectAll("*").remove();
                d3.select("#x-axis-svg").selectAll("*").remove();

                const totalHeightValue = calculateTotalHeight(data, intervalWidths, rowHeight, groupSpacing, margin);
                if (isNaN(totalHeightValue) || totalHeightValue <= 0 || !isFinite(totalHeightValue)) {
                    console.error("Total height 计算失败，跳过绘图。");
                    return;
                }

                drawChart(intervalWidths, intervalPositions, total, totalHeightValue);
                drawMinimap(intervalPositions, totalHeightValue, intervalWidths);
                }


            function drawChart(intervalWidths, intervalPositions, total, totalHeight, positions = null) {
                    
                if (isNaN(totalHeight) || totalHeight <= 0 || !isFinite(totalHeight)) {
                    console.error("Invalid total height:", totalHeight);
                    return;
                }

                const svg = d3.select("#chart")
                    .append("svg")
                    .attr("width", width)
                    .attr("height", totalHeight);

                // 清除旧的 pattern 定义
                svg.select('defs').selectAll('pattern').remove();

                if (!positions) {
                    positions = calculatePositions(data, intervalWidths, rowHeight, rectSpacing, margin, intervalPositions);
                }
            
                
            function createPattern(svg, id, url) {
                return svg.select('defs').append('pattern')
                    .attr('id', id)
                    .attr('patternUnits', 'objectBoundingBox')
                    .attr('width', 1)
                    .attr('height', 1)
                    .append('image')
                    .attr('xlink:href', url)
                    .attr('width', 2 * innerRadius)
                    .attr('height', 2 * innerRadius)
                    .attr('preserveAspectRatio', 'xMidYMid slice')
                    .attr('x', 0)
                    .attr('y', 0)
                    .on("error", function() {
                        console.error("Image load error: " + url); // 检查图像是否加载成功
                    });
            }   const colors = d3.scaleOrdinal(d3.schemeCategory10)
                .domain(sortedTimes); // 确保 domain 包含所有可能的 time 值

            // 先绘制所有的 rect
            svg.append("g")
                .selectAll("rect")
                .data(positions.filter(d => d.border))
                .enter()
                .append("rect")
                .attr("x", d => d.x)
                .attr("y", d => d.y)
                .attr("width", d => Object.values(intervalWidths).reduce((a, b) => a + b, 0))
                .attr("height", d => d.height)
                .attr("fill",  d => colors(d.time) || "#ccc")
                .attr("stroke", d => colors(d.time) || "#ccc")  // 这里使用 colors(d.time) 而不是 colors[d.time]
                .attr("stroke-width", 6)
                .attr("opacity", 0.3);


                // 然后过滤掉没有图片的 positions 数据，仅绘制 circle 相关的元素
                const filteredPositions = positions.filter(d => d.r_photo_env1 !== undefined && d.r_photo_env1 !== null && d.r_photo_env1 !== '');

                svg.append('defs');
                filteredPositions.forEach((d, i) => {
                    const patternId = `pattern-${i}`;
                    createPattern(svg, patternId, d.r_photo_env1);
                });

                const tooltip = d3.select("#tooltip");
                const circles = svg.append('g')
                    .selectAll("g")
                    .data(filteredPositions)
                    .enter()
                    .append("g")
                    .attr("transform", d => `translate(${d.x + circleRadius}, ${d.y + circleRadius})`);

                let intervalId;  // 定义在外部以便在 `mouseout` 时清除

                circles.on("mouseover", function(event, d) {
                    // 显示 tooltip
                    tooltip.style("display", "block");

                    // 更新 tooltip 内容
                    tooltip.select("#tooltip-title").text(d.r_name || "");
                    tooltip.select("#tooltip-food-dishes").html(`
                        <div style="display: flex; flex-wrap: wrap; margin-bottom: 5px;">
                            ${d.r_food_dishes.split('、').slice(0,3).map(dish => `
                                <div style="background-color: #FFD700; padding: 3px 5px; margin-right: 5px; margin-bottom: 5px; font-size: 12px; border-radius: 5px; white-space: nowrap;">
                                    ${dish}
                                </div>
                            `).join('')}
                        </div>
                    `);

                    tooltip.select("#tooltip-rating")
                        .style("font-size", "15px")  // 调整字体大小为 13px
                        .text(`評分: ${d.r_rating} 星`);

                    tooltip.select("#tooltip-ratings").html(`
                        <div style="display: flex; align-items: center; margin-bottom: 0px; font-size: 12px; max-width: 200px;">
                            <span style="width: 40px;">服務:</span>
                            <div style="background-color: #ccc; width: 100px; height: 8px; border-radius: 5px; overflow: hidden; position: relative;">
                                <div style="background-color: gold; width: ${d.r_rate_service * 20}px; height: 8px;"></div>
                            </div>
                            <span style="margin-left: 5px; white-space: nowrap;">${d.r_rate_service} 星</span>
                        </div>
                        <div style="display: flex; align-items: center; margin-bottom: 0px; font-size: 12px; max-width: 200px;">
                            <span style="width: 40px;">食物:</span>
                            <div style="background-color: #ccc; width: 100px; height: 8px; border-radius: 5px; overflow: hidden; position: relative;">
                                <div style="background-color: gold; width: ${d.r_rating_food * 20}px; height: 8px;"></div>
                            </div>
                            <span style="margin-left: 5px; white-space: nowrap;">${d.r_rating_food} 星</span>
                        </div>
                        <div style="display: flex; align-items: center; margin-bottom: 0px; font-size: 12px; max-width: 200px;">
                            <span style="width: 40px;">環境:</span>
                            <div style="background-color: #ccc; width: 100px; height: 8px; border-radius: 5px; overflow: hidden; position: relative;">
                                <div style="background-color: gold; width: ${d.r_rate_atmosphere * 20}px; height: 8px;"></div>
                            </div>
                            <span style="margin-left: 5px; white-space: nowrap;">${d.r_rate_atmosphere} 星</span>
                        </div>
                        <div style="display: flex; align-items: center; font-size: 12px; max-width: 200px;">
                            <span style="width: 40px;">衛生:</span>
                            <div style="background-color: #ccc; width: 100px; height: 8px; border-radius: 5px; overflow: hidden; position: relative;">
                                <div style="background-color: gold; width: ${d.r_rate_clean * 20}px; height: 8px;"></div>
                            </div>
                            <span style="margin-left: 5px; white-space: nowrap;">${d.r_rate_clean} 星</span>
                        </div>
                    `);


                    const images = [d.r_photo_env1, d.r_photo_env2, d.r_photo_env3];
                    let currentImageIndex = 0;
                    const carouselImages = tooltip.select("#carousel-images");

                    // 清空旧的图片
                    carouselImages.html("");

                    // 添加新的图片到轮播
                    images.forEach(imgUrl => {
                        carouselImages.append("img")
                            .attr("src", imgUrl)
                            .attr("style", "width: 100%; height: auto; object-fit: cover; border-radius: 8px;"); // 确保图片填满容器并保持比例
                    });

                    // 启动轮播
                    const intervalId = setInterval(() => {
                        currentImageIndex = (currentImageIndex + 1) % images.length;
                        carouselImages.style("transform", `translateX(-${currentImageIndex * 100}%)`);
                    }, 3000); // 每3秒切换一次图片

                    d3.select(this).on("mouseout", function() {
                        // 隐藏 tooltip 并停止轮播
                        clearInterval(intervalId);
                        tooltip.style("display", "none");
                    });
                })
                .on("mousemove", function(event) {
                    // 获取 tooltip 的宽度和高度
                    const tooltipWidth = tooltip.node().offsetWidth;
                    const tooltipHeight = tooltip.node().offsetHeight;

                    // 计算页面右侧边界距离
                    const pageWidth = window.innerWidth;
                    const totalHeight = calculateTotalHeight(data, intervalWidths, rowHeight, groupSpacing, margin);

                    // 默认位置：鼠标右下方
                    let leftPosition = event.pageX + 10;
                    let topPosition = event.pageY + 10;

                    // 如果 tooltip 会超出页面右侧边界，则显示在鼠标左侧
                    if (leftPosition + tooltipWidth > pageWidth) {
                        leftPosition = event.pageX - tooltipWidth - 10;
                    }

                    // 如果 tooltip 会超出画布底部，则显示在鼠标上方
                    if (topPosition + tooltipHeight > totalHeight) {
                        topPosition = event.pageY - tooltipHeight - 10;
                    }

                    // 更新 tooltip 位置
                    tooltip
                        .style("left", leftPosition + "px")
                        .style("top", `${topPosition}px`);
                });


                // 繪製圓圈並填充初始圖片
                circles.append("circle")
                    .attr("r", innerRadius)
                    .style("fill", function(d, i) {
                        const patternId = `pattern-${i}`;
                        return `url(#${patternId})`;
                    });

                                    
                const radius = 60;
                const leftData = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
                const color = d3.scaleOrdinal(d3.schemeSet3);

                const leftPie = d3.pie()
                    .startAngle(-Math.PI)
                    .endAngle(0)
                    .value(d => d);

                const leftDataReady = leftPie(leftData);

                const daysOfWeek = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"];
                const dayColor = d => d === 1 ? "#FFD400" : "lightgrey";  // 1为营业时间用黄色，0为不营业用灰色

                filteredPositions.forEach(d => {
                    // 初始化 rightData 为 0，表示没有营业时间
                    let rightData = daysOfWeek.map(() => 0);

                    // 将字符串转换为有效的 JSON 格式
                    let r_hours_weekday = [];
                    try {
                        const correctedString = d.r_days.replace(/'/g, '"');  // 将单引号替换为双引号
                        r_hours_weekday = JSON.parse(correctedString);
                    } catch (e) {
                        console.error("Failed to parse r_days:", d.r_days, e);
                    }

                // 对每一天进行检查，如果有营业时间的关键字，则设为 1
                rightData = daysOfWeek.map(day => {
                    return r_hours_weekday.some(entry => entry.includes(day)) ? 1 : 0;
                });

                console.log("rightData for", d.r_name, rightData); // 调试信息

                const rightPie = d3.pie()
                    .startAngle(0)
                    .endAngle(Math.PI)
                    .value(() => 1);  // 每一天都占据一个相等的分量

                const rightDataReady = rightPie(rightData);

                const arc = d3.arc()
                    .innerRadius(innerRadius)
                    .outerRadius(radius)
                    .cornerRadius(2);

                const circles = svg.append('g')
                    .selectAll("g")
                    .data([d])  // 这里使用当前的数据
                    .enter()
                    .append("g")
                    .attr("transform", d => `translate(${d.x + circleRadius}, ${d.y + circleRadius})`);

                circles.selectAll('path.right')
                    .data(rightDataReady)
                    .enter()
                    .append('path')
                    .attr('class', 'right')
                    .attr('d', arc)
                    .attr('fill', (d, i) => dayColor(rightData[i]))  // 确保颜色函数根据 rightData 的值返回正确的颜色
                    .attr("stroke", "white")
                    .style("stroke-width", "1px");

                // 绘制右侧的文字
                const days = ["M", "T", "W", "T", "F", "S", "S"];
                circles.selectAll('text.days')
                    .data(rightDataReady)
                    .enter()
                    .append('text')
                    .attr('class', 'days')
                    .attr('transform', d => {
                        const pos = arc.centroid(d);
                        return `translate(${pos[0]},${pos[1]})`;
                    })
                    .attr('text-anchor', 'middle')
                    .attr('dy', '0.35em')
                    .attr('font-size', '10px')
                    .attr('font-weight', 'bold')
                    .text((d, i) => days[i]);

                console.log(rightDataReady); // 调试信息
            });


                circles.selectAll('path.left')
                    .data(leftDataReady)
                    .enter()
                    .append('path')
                    .attr('class', 'left')
                    .attr('d', d3.arc()
                        .innerRadius(innerRadius)
                        .outerRadius(radius)
                        .cornerRadius(2)
                    )
                    .attr('fill', (d, i) => color(i))
                    .attr("stroke", "white")
                    .style("stroke-width", "1px");


                const smallCircleRadius = 10;
                const iconOffset = radius + smallCircleRadius + 2;
                // Add star icon

                circles.append('circle')
                    .attr('cx', d => Math.cos(-Math.PI / 5) * iconOffset)
                    .attr('cy', d => Math.sin(-Math.PI / 5) * iconOffset)
                    .attr('r', smallCircleRadius)
                    .attr('fill', 'white')
                    .attr('stroke', 'black')
                    .attr('stroke-width', '1px');

                circles.append("text")
                    .attr("x", Math.cos(-Math.PI / 5) * iconOffset)
                    .attr("y", Math.sin(-Math.PI / 5) * iconOffset)
                    .attr("text-anchor", "middle")
                    .attr("alignment-baseline", "middle")
                    .attr("font-size", "15px")
                    .attr("class", "fas fa-star")
                    .attr("fill", "#FFD400")
                    //.attr("opacity", 0.5)
                    .text('\uf005'); // Font Awesome - star (Unicode)

                // 添加星星评分
                circles.append("text")
                    .attr("x", Math.cos(-Math.PI / 5) * iconOffset) // 调整位置
                    .attr("y", Math.sin(-Math.PI / 5) * iconOffset)
                    .attr("text-anchor", "middle")
                    .attr("alignment-baseline", "middle")
                    .attr("font-size", "12px")
                    .attr("font-weight", "bold")
                    .text(function(d) {
                        console.log('Rating:', d.r_rating);  // 检查评分数据
                        return d.r_rating !== undefined ? d.r_rating : 'N/A'; // 如果未定义，返回占位符
                    });

                // 添加停车图标
                circles.append('circle')
                    .attr('cx', Math.cos(-Math.PI / 4 + 0.5) * iconOffset)
                    .attr('cy', Math.sin(-Math.PI / 4 + 0.5) * iconOffset)
                    .attr('r', smallCircleRadius)
                    .attr('fill', 'white')
                    .attr('stroke', 'black')
                    .attr('stroke-width', '1px');

                    circles.append("text")
                    .attr("x", Math.cos(-Math.PI / 4 + 0.5) * iconOffset)
                    .attr("y", Math.sin(-Math.PI / 4 + 0.51) * iconOffset)
                    .attr("text-anchor", "middle")
                    .attr("alignment-baseline", "middle")
                    .attr("font-size", "15px")
                    .attr("class", "fas fa-parking")
                    .attr('fill', d => {
                    if (d.r_has_parking == 1) {
                            return 'blue'; // If there is parking, set color to blue
                        } else {
                            return 'lightgrey'; // If there is no parking, set color to light grey
                        }
                    })
                    .text('\uf540'); // Font Awesome - parking (Unicode)
                    
                // 绘制带透明边框的矩形，并根据用餐时间设置背景颜色
                const timeColorMap = sortedTimes.reduce((map, time, index) => {
                    map[time] = colors(index);
                    return map;
                }, {});


                // 绘制白色线条
                svg.append("g")
                    .selectAll(".interval-separator")
                    .data(currentIntervals)
                    .enter()
                    .append("line")
                    .attr("class", "interval-separator")
                    .attr("x1", (d, i) => i < currentIntervals.length - 1 ? intervalPositions[d] + intervalWidths[d] : null)  // 只为非最后一个区间绘制线条
                    .attr("y1", margin.top)
                    .attr("x2", (d, i) => i < currentIntervals.length - 1 ? intervalPositions[d] + intervalWidths[d] : null)  // 只为非最后一个区间绘制线条
                    .attr("y2", totalHeight - margin.bottom)
                    .attr("stroke", "white")  // 将线条颜色设置为白色
                    .attr("stroke-width", 2);



                svg.append("g")
                    .selectAll("text")
                    .data(positions.filter(d => d.label))
                    .enter()
                    .append("text")
                    .attr("x", margin.left) // 調整 x 坐標
                    .attr("y", d => d.y - 10) // 調整 y 坐標
                    .attr("dy", "0.35em")
                    .attr("text-anchor", "start")
                    .attr("font-size", "12px")
                    .attr("font-weight", "bold")
                    .attr("fill", "black") // 添加顏色以確保文本可見
                    .text(d => `用餐時間: ${d.r_time_low}`);
                    console.log('Positions with labels:', positions.filter(d => d.label));
                    
                // 设置 SVG 宽度为 1200px
                const xAxisSvg = d3.select("#x-axis-svg")
                    .attr("width", 1200)
                    .attr("height", 50);  // 高度可以根据需求调整

                const svgWidth = 1200; // 设置目标宽度
                const totalWidth = d3.sum(Object.values(intervalWidths)); // 计算所有区间的总宽度

                // 使用 d3.scaleLinear() 将区间映射到 1200px 的宽度范围
                const xScale = d3.scaleLinear()
                    .domain([0, totalWidth])
                    .range([0, svgWidth]);

                // 调试输出，检查 xScale 的值是否正确映射
                const scaledPositions = currentIntervals.map(interval => ({
                    interval: interval,
                    originalPosition: intervalPositions[interval],
                    scaledPosition: xScale(intervalPositions[interval])
                }));

                console.log("xScale values:", scaledPositions);

                // 重新绘制 X 轴
                xAxisSvg.append("g")
                    .attr("transform", `translate(0, 0)`)
                    .call(d3.axisBottom(xScale)
                        .tickValues(scaledPositions.map(d => d.originalPosition))  // 使用实际的位置值
                        .tickFormat((d, i) => {
                            const closestInterval = scaledPositions.find(pos => pos.originalPosition === d);
                            return closestInterval ? closestInterval.interval : '';  // 返回最近的区间标签或空字符串
                        })
                    );


                // 向右移動的箭頭
                d3.select("body").append("div")
                    .attr("class", "arrow arrow-right")
                    .text("▶")
                    .on("click", () => {
                        const nextIndex = intervals.indexOf(currentIntervals[currentIntervals.length - 1]) + 1;
                        if (nextIndex < intervals.length) {
                            currentIntervals = intervals.slice(nextIndex - 2, nextIndex + 1);
                            updateIntervals();
                        }
                    });

                // 向左移動的箭頭
                d3.select("body").append("div")
                    .attr("class", "arrow arrow-left")
                    .text("◀")
                    .on("click", () => {
                        const prevIndex = intervals.indexOf(currentIntervals[0]) - 1;
                        if (prevIndex >= 0) {
                            currentIntervals = intervals.slice(prevIndex, prevIndex + 3);
                            updateIntervals();
                        }        
                    });
            }

            function calculatePositions(data, intervalWidths, rowHeight, rectSpacing, margin, intervalPositions) {
                const positions = [];
                let groupYOffset = margin.top;

                // 確保每個間隔的最小寬度能放置一個圓圈
                Object.keys(intervalWidths).forEach(key => {
                    if (intervalWidths[key] < circleRadius * 2) {
                        intervalWidths[key] = circleRadius * 2 + rectSpacing;
                    }
                });

                sortedTimes.forEach(time => {
                    const groupData = currentIntervals.map(interval => ({
                        key: interval,
                        value: data.filter(d => d.r_time_low == time && categorizePrice(d.r_price_low) === interval).length
                    }));

                    // 檢查該時間段是否有任何餐廳
                    const hasData = groupData.some(d => d.value > 0);
                    if (!hasData) {
                        // 如果沒有任何餐廳，跳過這個時間段
                        return;
                    }

                    const maxRows = Math.max(...groupData.map(d => {
                        const value = d.value || 0;
                        const width = intervalWidths[d.key] || 0;
                        const maxItemsPerRow = width > 0 ? Math.max(1, Math.floor(width / (circleRadius * 2 + rectSpacing))) : 1;
                        return Math.ceil(value / maxItemsPerRow);
                    }));

                    const groupHeight = maxRows > 0 ? maxRows * (circleRadius * 2 + rectSpacing) : 10;  // 如果沒有數據，默認高度為10
                    positions.push({
                        x: margin.left,
                        y: groupYOffset,
                        width: Math.max(...Object.values(intervalWidths)) - margin.left - margin.right,
                        height: groupHeight + 40, // 增加高度
                        key: '',
                        time: time,
                        border: true,
                        label: true, // 設置 label 屬性
                        r_time_low: time // 包含需要顯示的用餐時間
                    });

                    const placedPositions = {};

                    groupData.forEach(group => {
                        let xOffset = 0;
                        let yOffset = groupYOffset;
                        const maxItemsPerRow = Math.floor(intervalWidths[group.key] / (circleRadius * 2 + rectSpacing));

                        // 过滤出属于当前group.key和time的餐厅
                        const restaurantsInGroup = data.filter(d => d.r_time_low == time && categorizePrice(d.r_price_low) === group.key);

                        restaurantsInGroup.forEach((restaurant, i) => {
                            if (i > 0 && i % maxItemsPerRow === 0) {
                                xOffset = 0;
                                yOffset += (circleRadius * 2 + rectSpacing);
                            }

                            let currentX = intervalPositions[group.key] + xOffset;
                            let posKey = `${currentX}-${yOffset}`;

                            // 检查是否有相同的 X 位置，若有则加上 radius 的宽度
                            while (placedPositions[posKey]) {
                                currentX += circleRadius * 2;
                                posKey = `${currentX}-${yOffset}`;
                            }

                            if (currentX + circleRadius * 2 > intervalPositions[group.key] + intervalWidths[group.key]) {
                                xOffset = 0;
                                yOffset += (circleRadius * 2 + rectSpacing);
                                currentX = intervalPositions[group.key] + xOffset;
                            }

                            positions.push({
                                x: currentX,
                                y: yOffset,
                                key: group.key,
                                time: time,
                                label: false,
                                r_name: restaurant.r_name,
                                r_photo_env1: restaurant.r_photo_env1,
                                r_photo_env2: restaurant.r_photo_env2,  // 添加第二张照片的URL
                                r_photo_env3: restaurant.r_photo_env3,  // 添加第三张照片的URL
                                r_rating: restaurant.r_rating,
                                r_has_parking: restaurant.r_has_parking,
                                r_food_dishes: restaurant.r_food_dishes,  // 添加菜餚信息
                                r_rate_clean: restaurant.r_rate_clean,    // 添加清潔度评分
                                r_rate_atmosphere: restaurant.r_rate_atmosphere,  // 添加氛圍评分
                                r_rate_service: restaurant.r_rate_service,  // 添加服务评分
                                r_rating_food: restaurant.r_rating_food, // 添加食物评分
                                r_days: restaurant.r_hours_weekday
                            });


                            placedPositions[posKey] = true;
                            xOffset += circleRadius * 2 + rectSpacing;
                        });
                    });

                    groupYOffset += groupHeight + groupSpacing + 40; // 增加垂直间距

                });

                return positions;
            }

            function calculateSortedPositions(data, intervalWidths, rowHeight, rectSpacing, margin, intervalPositions) {
                    const positions = [];
                    let groupYOffset = margin.top;

                    // 确保每个间隔的最小宽度能放置一个圆圈
                    Object.keys(intervalWidths).forEach(key => {
                        if (intervalWidths[key] < circleRadius * 2) {
                            intervalWidths[key] = circleRadius * 2 + rectSpacing;
                        }
                    });

                    sortedTimes.forEach(time => {
                        // 按 `r_rating` 对数据排序，并过滤属于当前区间的餐厅
                        const groupData = currentIntervals.map(interval => ({
                    key: interval,
                    items: data
                        .filter(d => d.r_time_low == time && (categorizePrice(d.r_price_low) === interval || !categorizePrice(d.r_price_low)))
                        .sort((a, b) => b.r_rating - a.r_rating)

                        }));

                        // 检查该时间段是否有任何餐厅
                        const hasData = groupData.some(group => group.items.length > 0);
                        if (!hasData) {
                            return;
                        }

                        const maxRows = Math.max(...groupData.map(group => {
                            const value = group.items.length;
                            const width = intervalWidths[group.key] || 0;
                            const maxItemsPerRow = width > 0 ? Math.max(1, Math.floor(width / (circleRadius * 2 + rectSpacing))) : 1;
                            return Math.ceil(value / maxItemsPerRow);
                        }));

                        const groupHeight = maxRows > 0 ? maxRows * (circleRadius * 2 + rectSpacing) : 10;

                        // 如果需要在区间中显示标签（如"用餐时间"），可以将其添加到positions数组中
                        positions.push({
                            x: margin.left,
                            y: groupYOffset,
                            width: Math.max(...Object.values(intervalWidths)) - margin.left - margin.right,
                            height: groupHeight + 40, // 调整高度以避免重叠
                            key: '',
                            time: time,
                            border: true,
                            label: true,
                            r_time_low: time
                        });

                        const placedPositions = {};

                        groupData.forEach(group => {
                            let xOffset = 0;
                            let yOffset = groupYOffset;
                            const maxItemsPerRow = Math.floor(intervalWidths[group.key] / (circleRadius * 2 + rectSpacing));

                        group.items.forEach((restaurant, i) => {
                            if (i > 0 && i % maxItemsPerRow === 0) {
                                xOffset = 0;
                                yOffset += (circleRadius * 2 + rectSpacing);
                            }

                            let currentX = intervalPositions[group.key] + xOffset;
                            let posKey = `${currentX}-${yOffset}`;

                            while (placedPositions[posKey]) {
                                currentX += circleRadius * 2;
                                posKey = `${currentX}-${yOffset}`;
                            }

                            if (currentX + circleRadius * 2 > intervalPositions[group.key] + intervalWidths[group.key]) {
                                xOffset = 0;
                                yOffset += (circleRadius * 2 + rectSpacing);
                                currentX = intervalPositions[group.key] + xOffset;
                            }

                            positions.push({
                                x: currentX,
                                y: yOffset,
                                key: group.key,
                                time: time,
                                label: false,
                                r_name: restaurant.r_name,
                                r_photo_env1: restaurant.r_photo_env1,
                                r_photo_env2: restaurant.r_photo_env2,  // 添加第二张照片的URL
                                r_photo_env3: restaurant.r_photo_env3,  // 添加第三张照片的URL
                                r_rating: restaurant.r_rating,
                                r_has_parking: restaurant.r_has_parking,
                                r_food_dishes: restaurant.r_food_dishes,  // 添加菜餚信息
                                r_rate_clean: restaurant.r_rate_clean,    // 添加清潔度评分
                                r_rate_atmosphere: restaurant.r_rate_atmosphere,  // 添加氛圍评分
                                r_rate_service: restaurant.r_rate_service,  // 添加服务评分
                                r_rating_food: restaurant.r_rating_food,// 添加食物评分
                                r_days: restaurant.r_hours_weekday  
                            });


                            placedPositions[posKey] = true;
                            xOffset += circleRadius * 2 + rectSpacing;
                        });
                    });

                    groupYOffset += groupHeight + groupSpacing + 40; // 调整垂直间距以避免重叠
                });

                return positions;
            }



            function calculateTotalHeight(data, intervalWidths, rowHeight, groupSpacing, margin) {
                let totalHeight = margin.top;

                sortedTimes.forEach(time => {
                    const groupData = currentIntervals.map(interval => ({
                        key: interval,
                        value: data.filter(d => d.r_time_low == time && categorizePrice(d.r_price_low) === interval).length
                    }));

                    // 檢查該時間段是否有任何餐廳
                    const hasData = groupData.some(d => d.value > 0);
                    if (!hasData) {
                        // 如果沒有任何餐廳，跳過這個時間段
                        return;
                    }

                    const maxRows = Math.max(...groupData.map(d => {
                        const value = d.value || 0;
                        const width = intervalWidths[d.key] || 0;
                        if (width === 0) return 0;
                        const maxItemsPerRow = Math.max(1, Math.floor(width / (circleRadius * 2 + rectSpacing)));
                        return Math.ceil(value / maxItemsPerRow);
                    }));

                    const groupHeight = maxRows > 0 ? maxRows * (circleRadius * 2 + rectSpacing) : 10;  // 如果没有数据，默认高度为10
                    console.log(`Group height for time ${time}:`, groupHeight);  // 查看组高度

                    if (isNaN(groupHeight) || groupHeight < 0) {
                        console.error("Invalid groupHeight:", groupHeight);
                        return;
                    }

                    totalHeight += groupHeight + groupSpacing + 40; // 增加间距
                });

                totalHeight += margin.bottom;

                if (isNaN(totalHeight) || totalHeight <= 0 || !isFinite(totalHeight)) {
                    console.error("Invalid total height calculated:", totalHeight);
                    return 0;
                }

                return totalHeight;
            }

            function drawMinimap(intervalPositions, totalHeight, intervalWidths) {
                const minimapWidth = 200;
                const minimapHeight = 100;

                const scaleX = d3.scaleBand()
                    .domain(intervals)
                    .range([0, minimapWidth])
                    .padding(0.1);

                // 保持 sortedTimes 的正確順序
                const reversedTimes = sortedTimes.slice().reverse();

                const intervalData = intervals.map(interval => {
                    const timeData = {};
                    reversedTimes.forEach(time => {
                        timeData[time] = data.filter(d => d.r_time_low === time && categorizePrice(d.r_price_low) === interval).length;
                    });
                    return {
                        interval: interval,
                        ...timeData
                    };
                });

                const maxYValue = d3.max(intervalData, d => d3.sum(reversedTimes.map(time => d[time])));

                // 調整 scaleY 的範圍，使其從最大值到 0 映射
                const scaleY = d3.scaleLinear()
                    .domain([maxYValue, 0])
                    .range([0, minimapHeight]);

                d3.select("#minimap").selectAll("*").remove();

                d3.select("#minimap")
                    .append("rect")
                    .attr("width", minimapWidth)
                    .attr("height", minimapHeight)
                    .attr("fill", "#ddd");

                const stack = d3.stack()
                    .keys(reversedTimes);

                const stackedData = stack(intervalData);
                colors = d3.scaleOrdinal(d3.schemeCategory10)

                // 反转层的顺序以应用反转颜色
                stackedData.reverse().forEach((layer, layerIndex) => {
                    d3.select("#minimap").selectAll(`.bar-${layer.key}`)
                        .data(layer)
                        .enter()
                        .append("rect")
                        .attr("class", `bar-${layer.key}`)
                        .attr("x", d => scaleX(d.data.interval))
                        .attr("y", d => scaleY(d[1]))
                        .attr("width", scaleX.bandwidth())
                        .attr("height", d => scaleY(d[0]) - scaleY(d[1]))
                        .attr("fill", colors(layerIndex))  // 反转后的颜色顺序
                        .attr("stroke", "black");
                });

                const currentStart = currentIntervals[0];
                const currentEnd = currentIntervals[currentIntervals.length - 1];
                const xPositionStart = scaleX(currentStart);
                const xPositionEnd = scaleX(currentEnd) + scaleX.bandwidth();

                d3.select("#minimap").append("rect")
                    .attr("x", xPositionStart)
                    .attr("y", 0)
                    .attr("width", xPositionEnd - xPositionStart)
                    .attr("height", minimapHeight)
                    .attr("stroke", "red")
                    .attr("stroke-width", 2)
                    .attr("fill", "none");

                intervals.forEach(interval => {
                    if (!currentIntervals.includes(interval)) {
                        d3.select("#minimap").append("rect")
                            .attr("x", scaleX(interval))
                            .attr("y", 0)
                            .attr("width", scaleX.bandwidth())
                            .attr("height", minimapHeight)
                            .attr("fill", "white")
                            .attr("fill-opacity", 0.5);
                    }
                });
            }

            updateIntervals();
        });
    </script>
</body>
</html>
